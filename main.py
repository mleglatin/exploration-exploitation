import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random

class reality:
    def __init__(self, dim,seq):
        self.dim = dim
        self.seq=seq
        self.vector=[]

    def create(self): #create random reality to start with
        random.seed()
        for i in range(self.dim):
            self.vector.append(random.choice(self.seq))
        #print(len(self.vector))

class beliefs: #code or individual

    def __init__(self, dim,p,seq,kind=1):
        self.dim = dim
        self.p= p
        self.seq=seq
        self.vector=[]
        self.kind=kind #0=code 1=individual

    def create(self,zeros=0): #create random beliefs to start with
        random.seed()
        for i in range(self.dim):
            if zeros==0:
                self.vector.append(random.choice(self.seq))
            else:
                self.vector.append(0)

    def update(self,vec):
        if self.kind==1:
            for i in range(self.dim):
                self.update_dim1(self,i,vec[i])

    def update_dim1(self,ind,belief): #compared to a given reference
        #ind pointing at specific dimension
        if belief_i!=0:
            if random.random()<p:
                self.vector[ind]=belief #update to follow the code

    def update_code(self,orga,reality): #update as if code
        for i in range(self.dim):
            if orga.get_reality_check(reality)[i]!=0:
                k=orga.get_reality_check(reality)[i]-orga.get_code_check(self)[i]
                if k>0: #more people are aligned with reality than the code
                    probability=(1-self.p)^k
                    if random.random()>probability:#the code learns
                        self.vector[i]=reality[i]

    def veccheck(self,vec):
        indexes=[]
        for i in range(self.dim):
            if self.vector[i]==vec[i]:
                indexes.append(i)
        return indexes

class organization:

    def __init__(self,size,dim,p,seq):
        self.size = size
        self.dim=dim
        self.p= p
        self.seq=seq
        self.pop=[]

    def create(self): #create random beliefs to start with
        for i in range(self.size):
            self.pop.append(beliefs(self.dim,self.p,self.seq,kind=1))

    def get_reality_check(self,reality):
        number=[0]*self.dim
        for k in range(self.size):
            indexes.append=self.pop[k].veccheck(reality) #

        for j in len(indexes):
            for i in range(self.dim):
                number[i]=number[i]+indexes[j].count(i)

        return number

    def get_code_check(self,code):
        number=[0]*self.dim
        for k in range(self.size):
            indexes.append=self.pop[k].veccheck(code)

        for j in len(indexes):
            for i in range(self.dim):
                number[i]=number[i]+indexes[j].count(i)

        return number #er dimension, #of individuals aligned with the code


    def updatebeliefs(self,code):
        for k in range(self.size):
            self.pop[k].update(code,1)


m=30
n=50
time=80
p1=0.5
p2=0.5

real=reality(m,[-1,1])
real.create()

code=beliefs(m,p1,[-1,0,1],0) #kind=0
code.create(zeros=1)

orga=organization(n,m,p2,[-1,0,1])
orga.create()

print(real)

codecheck=[]*time
realitycheck=[]*time

for t in range(time):
    realitycheck[t]=orga.get_reality_check(real)
    codecheck[t]=orga.get_code_check(code)

    orga.updatebeliefs(code)
    code.update_code(orga,real)


plt.plot(range(time),codecheck, marker='o')
plt.plot(range(time),realitycheck, marker='+')
